const { PrismaClient } = require("@prisma/client");
const prisma = new PrismaClient();

const generateUniqueId = () => {
  return Math.random().toString(36).substr(2, 9);
};

const createCourseRequest = async (profId, courseId) => {
  const existingRequests = await prisma.prof_course_req.findMany({
    where: { iid: profId },
  });

  const pendingCount = existingRequests.filter(
    (req) => req.accept_reject === null
  ).length;
  const acceptedCount = existingRequests.filter(
    (req) => req.accept_reject === true
  ).length;

  if (pendingCount + acceptedCount >= 2) {
    throw new Error("At most 2 course requests allowed at a time.");
  }

  const course = await prisma.pre_final_courses.findUnique({
    where: { course_id: courseId },
  });
  if (!course) throw new Error("Course not found.");

  const chairperson = await prisma.chairperson.findFirst({
    where: { chairperson_school: course.school },
  });
  if (!chairperson) throw new Error("Chairperson not found for the school.");

  // Insert into prof_course_pre_final (relation definition)
  await prisma.prof_course_pre_final.create({
    data: {
      uid: generateUniqueId(),
      course_id: courseId,
      iid: profId,
    },
  });

  // Insert request into prof_course_req
  const newRequest = await prisma.prof_course_req.create({
    data: {
      request_id: generateUniqueId(),
      iid: profId,
      course_code: course.course_code,
      chairperson_id: chairperson.chairperson_id,
    },
  });

  return newRequest;
};

const cancelCourseRequest = async (profId, courseId) => {
  const course = await prisma.pre_final_courses.findUnique({
    where: { course_id: courseId },
  });
  if (!course) throw new Error("Course not found.");

  const request = await prisma.prof_course_req.findFirst({
    where: {
      iid: profId,
      course_code: course.course_code,
      accept_reject: null, // Only pending can cancel
    },
  });
  if (!request) throw new Error("No pending request found.");

  // Remove from prof_course_pre_final
  await prisma.prof_course_pre_final.deleteMany({
    where: { iid: profId, course_id: courseId },
  });

  // Remove from prof_course_req
  await prisma.prof_course_req.delete({
    where: { request_id: request.request_id },
  });

  return { message: "Request cancelled successfully." };
};

const resolveRequest = async (acceptIds, rejectIds) => {
  // Update all accepted IDs: set accept_reject = true
  await Promise.all(
    acceptIds.map(id =>
      prisma.prof_course_req.update({
        where: { request_id: id },
        data: { accept_reject: true },
      })
    )
  );

  // Update all rejected IDs: set accept_reject = false
  await Promise.all(
    rejectIds.map(id =>
      prisma.prof_course_req.update({
        where: { request_id: id },
        data: { accept_reject: false },
      })
    )
  );

  return { message: "Request RESOLVED successfully." };
};



const getCoursesRequestedByProfessor = async (profId) => {
  return await prisma.prof_course_pre_final.findMany({
    where: { iid: profId },
    include: { course: true },
  });
};

const getProfessorsRequestedCourse = async (courseId) => {
  return await prisma.prof_course_pre_final.findMany({
    where: { course_id: courseId },
    include: { professor: true },
  });
};

module.exports = {
  createCourseRequest,
  cancelCourseRequest,
  getCoursesRequestedByProfessor,
  getProfessorsRequestedCourse,
  resolveRequest,
};
